<html><head><title>DomAPI Docs - Tutorial - Remote Procedure Calls (RPC)</title><link rel="stylesheet" type="text/css" href="../docs/bin/style.css"></head><body><div id="logo"><a href="http://domapi.com"><img src="../docs/bin/logo6.gif" alt="DomAPI Application Platform" border="0" /></a></div><a href="#" onclick="history.go(-1)"><img src="../docs/bin/left.gif" alt="Back" width="14" height="14" border="0"></a><a href="#" onclick="history.go(-1)">Back</a>&nbsp;&nbsp;&nbsp; <a href="tutor_index.htm"><img src="../docs/bin/up.gif" alt="Up to index" width="14" height="14" border="0"></a><a href="tutor_index.htm">Up to index</a><h3>DomAPI Tutorial</h3><div class="tutorNavBlock"><a href="tutor_22.htm"><img src="../docs/bin/left.gif" alt="Back" width="14" height="14" border="0"></a><a href="tutor_22.htm" title="Back">Overview</a> &nbsp;&nbsp;&nbsp; <a href="tutor_index.htm"><img src="../docs/bin/up.gif" alt="Up to index" width="14" height="14" border="0"></a> &nbsp;&nbsp;&nbsp; <a href="tutor_38.htm" title="Next">XMLCore</a><a href="tutor_38.htm"><img src="../docs/bin/right.gif" alt="Next" width="14" height="14" border="0"></a></div><h3>Remote Procedure Calls (RPC)</h3><p class="tutorAuthor"> Author: <b>Darin Kadrioski</b><br /><span style="font-size:smaller">Modified: 06/21/2002</span></p><p style="font-weight:bold"> NOTE: The server-side examples in this tutorial use Coldfusion. You can use any backend language you prefer, the concepts are easy enough to adapt. </p><h4>Introduction</h4><p> RPC is short for Remote Procedure Call. It is a method whereby you can send a message to a server and receive back a response. This can used for example to create and edit records in a database on the server, or to return datasets from the server back to the client. The idea is that this interaction between server and client can occur without needing to reload the page. </p><p> In order to understand how RPC works, you need a clear understanding of what code executes on the server and which on the client. The client will have the DomAPI loaded and will make a request to the server. This request is nothing more than a URL with parameters describing the request to the server. The server then responds by sending back pure Javascript, formatted in such a way that the RPC unit in DomAPI knows what to do with it. The code returned from the server also is responsible for firing an event on the client to let the RPC engine know that the request is complete. Many requests can be in transit at any given time (although most servers limit connections to 3 at a time) but the engine keeps them all separated by assigning a GUID or Globally Unique IDentifier to each. The DomAPI RPC engine offers you a number of flexible ways to hook into these events to make sure your data gets to where it needs to be. </p><h4>RPCPacket Object</h4><p> Data is exchanged between the client and server via an object called <span class="inlinecode">RPCPacket</span>. This object takes two parameters at creation: a url for the method call and an optional status string to be displayed in the statusbar while the command is in motion. Once created, you can add extra parameters to be sent to the server via the packet's <span class="inlinecode"> data</span> property. The data property is a DomAPI List object and the contents of it will be sent to the server with the request. To actually send the request, use the <span class="inlinecode">core.rpc.sendPacket()</span> routine. </p><p> Here is an example of creating and sending a packet to the server. This example sends a request to add a new user. It is assumed that you have already collected the username, email address and desired password from the user. This example calls a file named addUser.cfm on the server. This file would be responsible for doing the actual work on the server. </p><pre class="code">var myPacket = new RPCPacket("addUser.cfm","Creating your account...");
  myPacket.data.add("username",usernameVar);
  myPacket.data.add("email",   emailVar);
  myPacket.data.add("password",passwordVar);
  core.rpc.sendPacket(myPacket);</pre><p> This has the effect of calling the addUser.cfm file on the server, passing it HTTP parameters called "username", "email" and "password". Each request also tacks on a parameter called "guid" which is the id that the DomAPI engine gave the packet when you created it. </p><p> Once DomAPI has sent the packet via <span class="inlinecode">core.rpc.sendPacket()</span>, it will wait for a response from the server. If it doesn't receive a response before <span class="inlinecode">core.rpc.timeout</span> expires (default is 30 seconds) the packet will have timed out and an event is raised on the client. Therefore, it is important that each request processed by the server return a response, even if it's only to say "ok, I got your request". Here is an example of what our addUser.cfm file might look like. The actual business logic is left to you, only the code pertaining to returning a response is shown. </p><pre class="code">&lt;cfparam name="guid" default="-1"&gt;
&lt;cfparam name="username" default=""&gt;
&lt;cfparam name="email" default=""&gt;
&lt;cfparam name="password" default=""&gt;
&lt;!--- perform the addition and whatnot here ---&gt;

&lt;cfoutput&gt;
var response = new RPCPacket();
response.guid = "#guid#";
response.data.add("someReturnVar","whatever");
core.rpc.receivePacket(response);
&lt;/cfoutput&gt;</pre><p> This can be a bit confusing the first time you see it. The first half of that code is executed on the server. The second half is actually <b>Javascript</b> that is sent back and <b>executed on the client</b>. In fact, all the client would see is: </p><pre class="code">var response = new RPCPacket();
response.guid = "G1050665493484616";
response.data.add("someReturnVar","whatever");
core.rpc.receivePacket(response);</pre><p> Notice that there is no script tags or includes. What the server returns must be pure unadulterated Javascript. This code will execute on the client in the scope of the main window, which is assumed will have the DomAPI library loaded. </p><p> Let's look closer at that output from the server.<br /> On the first line, a response packet is created using the same <span class="inlinecode">RPCPacket</span> object we used to send the request. Next we set this packet's <span class="inlinecode">guid</span> property to match what was sent in with the request. This is extremely important as it's how the RPC engine links up responses with requests. On the next line we add a value to the <span class="inlinecode">data</span> collection. This is merely as an example of how you can return data back to the client. You can have the server return as much data as you need using this technique. Also, any valid Javascript Object can be added to the data <span class="inlinecode">data</span> collection, including Arrays and other Objects. Finally, the line <span class="inlinecode">core.rpc.receivePacket(response);</span> signals the RPC engine that the request was was received and allows it to then dispatch the proper events. </p><h4>Closing the Loop with Events</h4><p> There are a couple of ways you can interact with the RPC engine in order to know when your packet requests and returned from the server. The first way is to assign a handler to the <span class="inlinecode">core.rpc.onreceive</span> event. This is a global event that fires after each packet is received, passing the packet to the event. For example: </p><pre class="code">onload = function(){
  core.rpc.onreceive = onreceive;
};
function onreceive(packet){
  // react to packet being received
  alert(packet.guid);
  alert(data.length);
};</pre><p><span class="inlinecode">core.rpc.onreceive</span> fires after <b>any</b> packet is received. If you wanted to assign an event that only fires when a certain packet is received, you can assign an event handler when you call <span class="inlinecode">core.rpc.sendPacket()</span>. In the first send example we used <span class="inlinecode">core.rpc.sendPacket()</span> to send a request to the server: </p><pre class="code">var myPacket = new RPCPacket("addUser.cfm","Creating your account...");
  core.rpc.sendPacket(myPacket);</pre><p> ... however <span class="inlinecode">core.rpc.sendPacket</span> can also take a second parameter which is the event to fire when the packet returns. Unlike <span class="inlinecode">core.rpc.onreceive</span>, the event you pass to <span class="inlinecode">core.rpc.sendPacket</span> will fire <b>only</b> when that single packet is returned. Here is an example that sends two separate packets, each with their own event handlers: </p><pre class="code">onload = function(){
  var p1 = new RPCPacket("getTopTable.cfm"   ,"Filling first table..." );
  var p2 = new RPCPacket("getBottomTable.cfm","Filling second table...");
  core.rpc.sendPacket(p1,ontoptable);
  core.rpc.sendPacket(p2,onbottomtable);
};
function ontoptable(packet){
  // react to packet being received
  core.getElm("table1").setText(packet.data.findValueByName("contents"));
};
function onbottomtable(packet){
  // react to packet being received
  core.getElm("table2").setText(packet.data.findValueByName("contents"));
};</pre><p> In this way, different event handlers can be setup to handle different packets. One important thing to keep in mind when sending multiple packets at a time, like in this example, is that they may not return in the order they were sent. Packets travel to and from the server in an asynchronous manner. If you have a set of RPC calls that need to be made in a certain order, chain them together by having the receipt of one packet trigger another, etc...<br /><br /><span class="inlinecode">core.rpc.sendPacket()</span> also takes two more optional parameters that you might find useful. The first is a timeout value, which is the number of milliseconds to wait before assuming a packet was lost. The global default for timeouts is 30 seconds, but you can overwrite it for each packet individually if you needed to. The other optional parameter is a timeout event handler. While the RPC engine offers a global timeout handler, this optional parameter allows you to specify an individualized handler for the particular packet being sent. For example: </p><pre class="code">core.rpc.sendPacket(p1,myReceive,40000,myTimeout);</pre><h4>Additional RPC Properties</h4><p> So far in this tutorial we have covered<br /><br /><span class="inlinecode">new RPCPacket(url,statusText);</span><br /><span class="inlinecode">core.rpc.sendPacket(packet,recvHandler,timeout,timeoutHandler);</span><br /><span class="inlinecode">core.rpc.receivePacket(packet);</span><br /><span class="inlinecode">core.rpc.onreceive(packet);</span><br /> and<br /><span class="inlinecode">core.rpc.timeout;</span><br /><br /> Additional properties you may find useful are:<br /><br /><span class="inlinecode">core.rpc.manageCursor;</span> Boolean value that tells if the engine should control changing the cursor back and forth from the busy icon when packets are in motion.<br /><span class="inlinecode">core.rpc.lastError;</span> If an error should raise, you can examine this property for the message text.<br /><span class="inlinecode">core.rpc.lastUrl;</span> Useful for debugging, contains last request sent.<br /><span class="inlinecode">core.rpc.onsend(packet);</span> This event fires after each packet is sent.<br /><span class="inlinecode">core.rpc.ontimeout(packet);</span> This event fires if a packet times out.<br /></p><h4>Conclusion</h4><p> The RPC engine was designed to be simple to use for the novice user, and yet still remain quite powerful and flexible for more advanced users. The examples on this page represent the simplest of circumstances and should fit most user's needs. The engine is flexible enough though to be extended in a myriad of powerful ways. </p><div class="tutorNavBlock"><a href="tutor_22.htm"><img src="../docs/bin/left.gif" alt="Back" width="14" height="14" border="0"></a><a href="tutor_22.htm" title="Back">Overview</a> &nbsp;&nbsp;&nbsp; <a href="tutor_index.htm"><img src="../docs/bin/up.gif" alt="Up to index" width="14" height="14" border="0"></a> &nbsp;&nbsp;&nbsp; <a href="tutor_38.htm" title="Next">XMLCore</a><a href="tutor_38.htm"><img src="../docs/bin/right.gif" alt="Next" width="14" height="14" border="0"></a></div><hr />  </body></html>
