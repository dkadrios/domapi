<html><head><title>DomAPI Docs - Tutorial - Working with Function Args</title><link rel="stylesheet" type="text/css" href="../docs/bin/style.css"></head><body><div id="logo"><a href="http://domapi.com"><img src="../docs/bin/logo6.gif" alt="DomAPI Application Platform" border="0" /></a></div><a href="#" onclick="history.go(-1)"><img src="../docs/bin/left.gif" alt="Back" width="14" height="14" border="0"></a><a href="#" onclick="history.go(-1)">Back</a>&nbsp;&nbsp;&nbsp; <a href="tutor_index.htm"><img src="../docs/bin/up.gif" alt="Up to index" width="14" height="14" border="0"></a><a href="tutor_index.htm">Up to index</a><h3>DomAPI Tutorial</h3><div class="tutorNavBlock"><a href="tutor_29.htm"><img src="../docs/bin/left.gif" alt="Back" width="14" height="14" border="0"></a><a href="tutor_29.htm" title="Back">Creating Components - Part 1</a> &nbsp;&nbsp;&nbsp; <a href="tutor_index.htm"><img src="../docs/bin/up.gif" alt="Up to index" width="14" height="14" border="0"></a> &nbsp;&nbsp;&nbsp; <a href="tutor_37.htm" title="Next">Simple Navigation Menu</a><a href="tutor_37.htm"><img src="../docs/bin/right.gif" alt="Next" width="14" height="14" border="0"></a></div><h3>Working with Function Args</h3><p class="tutorAuthor"> Author: <b>Darin Kadrioski</b><br /><span style="font-size:smaller">Modified: 11/01/2004</span></p><p> One of the key concepts you have to grasp to use DomAPI to it's fullest potential is how it passes complex parameter sets to functions. </p><p> Whenever a long list of parameters needs to be sent to a function, especially if that list may change or if many of the items are optional, DomAPI instead uses a single object to encapsulate all the parameters. This is true for nearly all Component constructors as well as a few select component methods here and there.</p><p> Using a single object in place of a variable length parameter list has many benefits: </p><div style="width:350px"><ul style="margin-top:0px"><li>Developer doesn't need to memorize or lookup the complete list and order of each parameter.</li><li>The parameter list can be added to or modified in the future without breaking existing code.</li><li>The developer can add their own custom properties to the function call without need to modify the source code.</li></ul></div><p> In order to understand how this works, you'll need to know how to create inline objects in Javascript.<br /> Most of us are familiar with the <span class="inlinecode">new Object()</span> notation for creating new, empty objects, but there is another notation that not only does the same thing, but allows us to populate the object with properties as well. This notation uses a set of curly braces to create the Object. Consider the following two code segments which accomplish the same thing: </p><pre class="code">// standard method
var zoo      = new Object();
zoo.lions    = 2;
zoo.giraffes = 4;
zoo.zebras   = 8;

// inline method
var zoo = {
  lions    = 2,
  giraffes = 4,
  zebras   = 8
};</pre><p> Both of these pieces of code produce an object called "zoo" which is populated with animal names and the number that the zoo contains of each. At first glance there doesn't seem to be much benefit to one technique over the other, but suppose we had a function called <span class="inlinecode">printBrochure()</span> which when passed a zoo object would print out the contents of it. By using the curly brace technique of creating the object, we can both create and call the function in one line of code. For example: </p><pre class="code">// standard method
var zoo      = new Object();
zoo.lions    = 2;
zoo.giraffes = 4;
zoo.zebras   = 8;
printBrochure(zoo);

// inline method
printBrochure({lions = 2,giraffes = 4,zebras = 8});</pre><p> As you can see, the inline method is much simpler and cleaner. </p><p> Now let's look at a more real-world example as it applies to DomAPI components.<br /> In this example we'll examine the constructor for the button component. </p><h4>The Problem</h4><p>In the past, the button constructor was as follows: </p><pre class="code">function Button(parent,theme,x,y,w,h,caption){};</pre><p>All of these parameters were optional and the component would provide defaults for any that were given <span class="inlinecode">null</span> values. So if you wanted create a button using all the defaults but specifying your own caption, you'd need a long string of nulls:</p><pre class="code">var btn1 = Button(null,null,null,null,null,null,'Open');</pre><p>That's a lot of nulls! What if later you decide the button width should be specified as 60, which <span class="inlinecode">null</span> would you have to switch to make this happen? What a pain!<br /> Perhaps at some point it's decided that each component should have an additional property in their constructor to control alignment. It might also be decided that this new parameter would be best as being third in the list. This would make the constructor look like this:</p><pre class="code">function Button(parent,theme,align,x,y,w,h,caption){};</pre><p> This would break everyone's existing code... not good. The alternative is to place the new <span class="inlinecode">align</span> parameter at the end of each constructor instead of at the third position. Since each component has a different number of parameters, this means <span class="inlinecode">align</span> will be at a different ordinal position for each one. Not exactly standard. </p><h4>The Solution</h4><p> That's the way things used to be. Now, starting with DomAPI v3.x, we can solve this using inline objects. Nearly every component now takes only a single parameter which is an object, typically referred to as <span class="inlinecode">arg</span>. What used to constitute the parameters (x, y, w, h, etc...) are now properties of this <span class="inlinecode">arg</span> object.<br /> As an example, here is an example using the new Button constructor: </p><pre class="code">var btn1 = Button({parent:null,theme:null,x:null,y:null,w:null,h:null,caption:'Open'});</pre><p>Another way to write this which may be easier to read is:</p><pre class="code">var btn1 = Button({
  parent  : null,
  theme   : null,
  x       : null,
  y       : null,
  w       : null,
  h       : null,
  caption : 'Open'
});</pre><p>Some notes about this syntax:<br /> First off, the order of the parameters is unimportant, they can appear in whatever order you prefer. Second, if you want to use the default value for a property, you no longer need to pass nulls. In fact our button example, where we only needed to specify the <span class="inlinecode">caption</span>, is properly written like so:</p><pre class="code">var btn1 = Button({caption:'Open'});</pre><p>Using the <span class="inlinecode">arg</span> method we also solve the problem of future expansion. In our contrived example above, we added a fictitious <span class="inlinecode">align</span> property which caused the previous constructor grief. Now it's just a simple matter to add it to the <span class="inlinecode">arg</span> without breaking existing code.</p><p>When using components in DomAPI, there are certain common properties that you can expect every component to accept. These are <span class="inlinecode">parent, theme, x, y, h</span> and <span class="inlinecode">w</span>. All of these parameters are completely optional, and the DomAPI engine will provide defaults for any that are missing. You can rely on any component taking these base parameters (it is mandated by the component class). In addition, some components may specify their own custom parameters such as the Button's <span class="inlinecode">caption</span>. Most of the time these are also optional and have default values, but this is left up to the component's author.</p><p>With DomAPI components, you are also free to make up your own parameters. When the component engine encounters parameters it wasn't expecting, it willfully adds them to the component. For instance, suppose we wanted to add a <span class="inlinecode">description</span> property to our button. We can simply pass that along in the constructors arg and it will be added to the button.</p><pre class="code">var btn1 = Button({caption:'Open',description:'This is my button'});
alert(btn1.description);</pre><h4>Conclusion</h4><p>Inline objects for constructors are a powerful addition to the DomAPI core and will ensure that future expansions do not break existing code. If you had any code written using the old constructor method you will need to convert it to the new system as it is <b>NOT</b> backwards compatible, but once you have converted it you'll never look back! There is no performance penalty for using them, and they make the library much more expressive and configurable.</p><p>We'll close with one more example. Let's say you were writing a game or an interface that required many buttons of the same size. One <b>very</b> efficient way to build these is to create the <span class="inlinecode">arg</span> object once and reuse it: <pre class="code">var btns = [];
var arg = {w:25,h:25};
for(var i=0;i&lt;11;i++)
  btns.push(Button(arg));</pre><div class="tutorNavBlock"><a href="tutor_29.htm"><img src="../docs/bin/left.gif" alt="Back" width="14" height="14" border="0"></a><a href="tutor_29.htm" title="Back">Creating Components - Part 1</a> &nbsp;&nbsp;&nbsp; <a href="tutor_index.htm"><img src="../docs/bin/up.gif" alt="Up to index" width="14" height="14" border="0"></a> &nbsp;&nbsp;&nbsp; <a href="tutor_37.htm" title="Next">Simple Navigation Menu</a><a href="tutor_37.htm"><img src="../docs/bin/right.gif" alt="Next" width="14" height="14" border="0"></a></div><hr />  </body></html>
